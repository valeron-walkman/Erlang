% задание 11(p11) запаковываем последовательно следующие дубликаты во вложеные списки

-module(p11).
-export([encode_modified/1]).

% создаем функцию, в которой 1-й элемент списка будет равен числу последующих повторяющихся подряд элементов, который будет добавлять 1-цу при данных условиях:
encode_modified([[Count,Elem]|[Elem|[]]])->
   [[Count+1,Elem]];

% делает тоже самое что и первая клоза, только если хвост последнего элемента не "пустой", то выносит хвост в след.список элементов:
encode_modified([[Count,Elem]|[Elem|T]])->
   encode_modified([[Count+1,Elem]|T]);

% если в списке есть еще список с одним элементом и с пустым хвостом, то на выходе получаем просто список с одним вложенным(первым) списком:
encode_modified([[Count,Elem1]|[Elem2|[]]])->
   [[Count,Elem1],Elem2];

% если в списке вложено два списка, и во втором в голове два одинаковых элемента, то на выходе выводим цыфру 2 и повторяющийся элемент в голову 2-го списка: 
encode_modified([[Count,Elem1]|[Elem2,Elem2|T]])->
   [[Count,Elem1]|encode_modified([[2,Elem2]|T])];

% если в списке есть еще список с двумя элементами, то первый список выводим без изменений, так как он уже обработан первыми двумя клозами, дальше создаем функцию, которая выводит элементы 2-го списка:
encode_modified([[Count,Elem1]|[Elem2|T]])->
   [[Count,Elem1]|encode_modified([Elem2|T])];

% если есть список без вложенных списков, и в голове списка два одинаковых элемента, то на выходе получаем функцию, которая выводит список и добавляет в голову 2-ку, затем повторяющийся элемент:
encode_modified([Elem1,Elem1|T])->
   encode_modified([[2,Elem1]|T]);

% если есть список без вложенных списков, и в голове списка два разных элемента, то на выходе выводим 1-й элемент, затем функцию, которая обрабатывает оставшиеся элементы: 
encode_modified([Elem1,Elem2|T])->
   [Elem1|encode_modified([Elem2|T])];

% если список пустой - выводим пустой список:
encode_modified([])->
   [].
